## 1. Arduino 生態圈

AVR 的一大優勢在於 Arduino 的生態圈多數脫離不了 AVR，Arduino 提供了非常好的抽象，簡化了繁瑣的設定、編譯、上傳程式碼等步驟，透過 IDE 操作初學者也可以輕易將程式碼上傳。

儘管如此，背後運作的仍然是 AVR（這裡不討論以 ARM chip 的 Arduino 開發板），更棒的是 Arduino 是開源的，任何一個人都可以上 GitHub 查看原始碼。比起剛開始就直接挑戰 Linux 原始碼，從 AVR 開始除了程式碼規模較小之外，有任何問題都可以直接使用 Arduino 實機測試。

## 2. 架構簡單

比起 intel 或是 ARM 指令集，AVR 的指令集相對少很多，打開 Attiny85 的 datasheet 也就 120 個指令，在學習上也就相對好上手。以 Attiny85 的 datasheet 為例，整個 datasheet 也才 234 頁，還算是相對好消化的範圍。

## 3. 方便取得、操作

除了可以直接用 Arduino 來學習 AVR 之外，對於比較進階的學習者來說也可以直接買單顆 IC 來學習。以 Attiny85 為例，只有 8 隻腳而且可以直接插麵包板接線，想要測試程式碼運作時相對方便許多。Attiny85 只要 50 ~ 60 台幣就能入手，網路上隨便都買得到，比一杯飲料還便宜，燒掉也不會太心疼。

另外 AVR chip 常見的儲存機制都是內建在晶片當中，只要有電源，不用外接任何設備就可以直接運作

- flash memory
- EEPROM
- SRAM
- 內部時脈

## 學這個有用嗎？

學這個又沒有實際用途，為什麼還要大費周章學？

的確，學習整個作業系統是完全不同的概念，儘管你把 AVR 的指令跟概念搞熟也不代表明天就能寫 linux kernel（請右轉 jserv），但這無關於有沒有實際用途，而是對於事物本質運作的好奇。

因此，我認為有這個想法時心態就已經完全不正確了。如同本系列的說明文一樣，這是一段感謝電、感謝電晶體、感謝現代計算機組織發展的歷程。

回頭想想計算機的歷史，發現電的存在、電晶體、積體電路、CPU 架構、半導體產業，簡直就是奇蹟。能夠在 21 世紀學習人類最偉大的智慧結晶，這件事情本身就已經夠迷人了。

質數的存在，最剛開始也只侷限在數論而已，但多年以後質數成為了密碼學的重要基礎，我們仰賴的 HTTPS 加密傳輸，就是以質數的性質構築而成的。

因此如果真要給答案的話，**本系列文章對你的職涯、寫程式的功力、薪水沒有任何幫助**，請不要浪費時間閱讀，謝謝。

## 本系列文規劃

要在 30 天內講完 AVR 的所有知識是非常困難的挑戰，因此可能省略部份概念或以較為精簡的文字帶過，文章會貼出參考資源，有興趣的讀者可以另外參考。

1. 前導：電是如何產生的
2. 前導：電晶體如何組成邏輯閘
3. 前導：計算機當中的重要電路（暫存器、記憶體、全加器）
4. 前導：中斷
5. 前導：準備工具
6. 第一部份：AVR 介紹
7. 第二部份：重要功能介紹
    1. timer/counter
    2. GPIO port
    3. ADC
8. 第三部份：進階功能介紹
    1. watchdog
    2. interrupt
    3. UART
    4. sleep
    5. EEPROM
9. 第四部份：PCB 製作（如果時間許可）
    1. 電源管理模組
    2. 如何使用 KiCad
    3. 如何製作電路
    4. 如何下單並製作 PCB

電的產生方式來自於一個簡單的事實：電磁感應。在感應線圈裡如果磁通量發生變化就會產生電。

雖然在現代這被視為理所當然的事情，但法拉第也花了相當長的時間做實驗，才發現這個來自於大自然的奇妙原理。特斯拉後來利用電磁感應原理發明了發電機的結構，是現代發電的重要基礎。

開頭有提到，**磁場的變化**才能產生電，為了讓磁場產生變化則需要動能（也可透過其他方式），發電廠透過煤、天然氣、核能等方式將水煮沸後產生蒸氣，蒸氣驅動磁鐵旋轉，旋轉後產生電。這是支撐人類文明的重要基礎。

對我來說這件事情很神奇，看似很複雜的電，背後來自於一個簡單的事實：電磁感應。讓我們再次感謝法拉第、感謝特斯拉。

## 電與地球

雖然如此，人類用來發電的方式也對地球造成不少污染，根據世界衛生組織統計，目前溫室氣體排放的比例當中有 27% 來自於發電。

人們越來越仰賴電力的消費，雖然電本身相當環保，沒有任何污染。但產生電的方式有很大一部分還是仰賴煤、天然氣。

![截圖 2021-09-14 下午8.15.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4c7ba725-6b46-4125-813f-6c579166efef/截圖_2021-09-14_下午8.15.29.png)

儘管已經有各種環保的發電科技正在發展，但離完全取代傳統發電還有很長一段路要走。

## 交流電與直流電

在台灣使用的插座電力為 110V/60Hz，如果就這樣將電直接送進去電子產品的話馬上就會壞掉。電子產品大多仰賴於邏輯信號，也就是透過高電位模擬 1，低電位模擬 0 的方式運作。除了 110V 的電壓會將大部分的零件給燒壞之外，不斷變化電位的交流電也會讓 0 與 1 的判斷變得不準確，因此我們需要將交流電變成穩定電壓的直流電才能正常運作。

明明交流電的電壓隨時都在變化，那麼到底是什麼東西為 110V？這個 110V 是指交流電的**有效值，**交流電在電阻上所產生的瓦特數與直流電壓 110V 時一樣時就稱之為有效值。用有效值當作通稱也很自然，畢竟我們用電器在乎的就是瓦特數。

一般的電子產品，工作電壓通常會在 3.3V ~ 12V（根據產品不同）之間，我們要怎麼將交流電變成直流電呢？

交流電轉換為直流電的過程分為幾個階段：

- 整流
- 穩壓
- 降壓

### 整流

降壓過後的電，仍然處於交流電，因此沒辦法直接送進電子產品內使用，需要近一步整流。

交流轉換為直流的過程稱之為整流，整流可分為**全波整流**以及**半波整流。**

由於全波整流的轉換效益較佳，常見的整流方法是透過橋式整流器來實作。橋式整流器最主要的原理是透過二極體單向導通的特性所組成，當交流電經過橋式整流器時會將原本為負的半週期轉換為正的，因此轉換過後的波形會長這樣。

![截圖 2021-09-15 下午6.54.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0324850c-b190-434b-8c24-a38351c8df9f/截圖_2021-09-15_下午6.54.25.png)

雖然已經是直流電了，但仍然有幾個問題需要解決：

- 仍然有非常大的起伏，不是理想的直流電壓
- 變壓過後的電壓還是太大，大約在 140V 左右

我們可以透過加入電容的方式讓輸出電壓更加平滑，減少鏈波。電容具有充放電的特性，可以在輸出電壓達到峰值下降時，減緩電壓下降的速度，讓輸出電壓趨於平穩。

![圖片來自於維基百科](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a2ae47e3-61fa-426b-b878-0e8bcd76ea0f/Untitled.png)

圖片來自於維基百科

儘管如此，電壓還是很高，我們該如何降壓呢？

## 降壓

從 140V 降壓到 5V，必須透過變壓器的幫忙才行。變壓器的主要原理是透過電磁感應來實現的，因此...，我們需要將剛剛辛苦轉換好的直流電再次轉換為交流電...。

所以整個過程變成交流→ 直流 → 交流 → 直流嗎？是的。

> 你在開玩笑嗎？
> 

聽起來很可笑，但你我日常在用的充電器就是以這樣的方式組成的。做充電器的公司也不是白痴，這麼做背後有一個非常重要的目的—盡可能減少變壓器的面積。

在[維基百科](https://zh.wikipedia.org/wiki/%E5%8F%98%E5%8E%8B%E5%99%A8)當中有關於變壓器的轉換公式。雖然看起來有點複雜，但從公式中可以得知一個事實，輸入電壓的頻率越高，在磁力固定的情況下面積越小。

再講得直白一點，頻率越低，變壓器越大；頻率越高，變壓器越小。

![截圖 2021-09-15 下午8.22.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59f31269-763a-48c6-842f-1b8e5045cd5a/截圖_2021-09-15_下午8.22.22.png)

因此，我們只要想辦法讓輸入電壓的頻率盡可能地高一點，就可以減少充電器的面積了。可是剛剛有提到輸入是直流電，要怎麼讓它再次變為交流電呢？答案是不斷地開開關關，既然電流有變化了，那麼當然可以產生電磁效應。

透過 MOSFET 或是 BJT 場效電晶體的開關特性，可以讓開關的頻率達到每秒 100KHz 甚至更高，這樣子的高頻率有助於減少變壓器的面積。這種電路也有個專有名詞，稱作 Flyback Converter（[維基百科](https://zh.wikipedia.org/wiki/%E8%BF%94%E9%A6%B3%E5%BC%8F%E8%AE%8A%E6%8F%9B%E5%99%A8)）。

好了，現在又變成交流電了，為了讓輸出再次變為直流電，在電路當中需要再次加入二極體與電容整流。

前面提到，一般的二極體雖具有單向導通的特性，但從導通切換到不導通的時間比較長，當頻率來到幾千赫茲後可能會不敷使用。為了因應這種高速切換的特性，通常會使用比較特殊的二極體—蕭特基二極體（Schottky Diode）來整流。

另外一個整流方式則是主動整流，或叫做同步整流，意思是透過電晶體的開關特性來整流。使用電晶體來整流最大的好處在於轉換的損失會比一般二極體來得小，但需要透過 IC 控制並加入更多元件，相對於使用蕭特基二極體來說比較複雜，成本也會比較高。

今年比較流行的話題 GAN 充電器，透過氮化鎵的特性，可以達到比一般電晶體更高的頻率，也就代表著變壓器可以在變得更小，或許也是值得關注的技術之一。

## 總結

今天這篇文章算是對電做了非常概括性的介紹，其重點在於現代用電是如何將交流電變成直流電給電子產品：

- 透過**橋式整流器**對交流電進行整流
- 使用電容（或是 pi 型整流）提高**有效電壓**並減少鏈波
- 使用變壓器降壓（Flyback Converter）
- 使用同步整流或是蕭特基二極體再次將交流變為直流

身為軟體工程師的我們，其實就是間接仰賴著電在討生活的，然而我發現我對這個來自大自然的禮物卻一無所知。

將交流電轉換成穩定直流電，再從產品的角度出發，如何將面積變得更小、減少損失、更安全，背後仍然是基礎科學的堆積，這應該就是 Engineering 的本質了吧。


對於組合語言，最大的迷思在於：「有了編譯器，為什麼我還要學組合語言？」，關於學習組合語言的好處我認為可以分成幾點討論。

### 1. 知道處理器（MCU）是如何運作的

由於編譯器會產生一些 bootstrap 程式碼，所以光看編譯器編譯後的程式碼，可能會比想像中的數量還多。為了深入底層，你可能還需要知道編譯器對於特定片段的程式碼是如何編譯的。

### 2. 簡單直覺

一旦了解組合語言的概念，其實它並沒有想像中那麼難理解。因為我們是直接撰寫組合語言，所以也不會有編譯器轉換時的隔閡。你也不需要再去學習各種語言特性，組合語言運作的方式不會因為 chip 不同而有變化。

學習組合語言不代表你必須要精通它，或是從此以後只能用組合語言撰寫，回頭看看人類發展高階語言的原因，正是因為組合語言的表達能力有限，繁瑣的操作也會造成開發人員的心智負擔，不過知道組合語言是如何運作的，能夠幫助你在使用高階語言撰寫程式時，對實際上電腦會如何運作有更深的了解。

因此，如果你真的想更了解 AVR 的架構，認識組合語言就是必經的一段過程。

---

## 語法

組合語言通常會由三個部分組成：操作、運算數 1（Operand）、運算數 2。舉例來說，在 AVR 當中若要將數字載入至暫存器當中可以這樣寫：

```
ldi r16, 00000001
```

在這段程式碼中，`ldi` 代表操作，在這裡指得是 load immediately，r16 為暫存器，00000001 則為數字。我們通常會將**操作**稱為指令（instruction），在 AVR 當中大部分的 instruction 都是一個 cycle。

在這邊要特別注意的是，並不是每個指令都能夠像這樣，後面直接接一個常數，而是要先將數字載入到暫存器之後，再繼續接下來的操作。

例如我希望計算 1 + 1 後將結果放入暫存器中，這樣寫是不對的：

```
add r16, 1, 1
```

而是需要先將 1 載入到暫存器中，再進行加法：

```
ldi r14, 1
ldi r15, 1
add r15, r14
```

## 定址模式（addressing mode）

在 AVR 當中有許多定址模式，最主要的目的在於簡化在記憶體（RAM）與暫存器之間的資料交換與操作。

### 1. Register Direct：single register

一個指令搭配一個暫存器，例如 `inc` 指令

```
inc r16
```

將暫存器 r16 增加 1。在 AVR 組合語言當中，通用暫存器會以 r 當作前綴加上數字表示，assembler 會對照 AVR 的架構將這些暫存器映射到對應的位址（Register File）。在 AVR 當中有 32 個暫存器，所以 r0 ~ r31 都是可使用的暫存器。

### 2. Register Direct: 2 registers

可使用兩個暫存器，如 `add` 指令

```
add r16, r17
mov r0, r1
```

### 3. I/O Direct

可以直接在暫存器與 I/O Port 間傳輸資料，最常見的就是 `in` 跟 `out` 指令：

```
in r16, PINB ; 將 PINB 的資料傳給暫存器 r16 
out PORTC, r16 ; 將 r16 的資料傳給 PORTC
```

在這邊可以發現 PINB 以及 PORTC 之類看起來很像變數的東西，這是由 assembler 事先定義的變數。在 AVR 當中除了通用暫存器（general purpose register）這類可以讓我們直接操作的暫存器之外，**還有控制各種功能、參數的暫存器可以使用。**

![截圖 2021-10-02 上午1.51.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b0a0a4a-ca96-485e-87c6-8588ff4ee50e/截圖_2021-10-02_上午1.51.28.png)

在 AVR 當中暫存器可以透過特定的位址存取，舉例來說 PORTB 這個暫存器就存在於 0x18 這個記憶體位址當中。不過直接撰寫記憶體位址撰寫時比較麻煩，因此 assembler 通常會事先定義好這些暫存器的位址與名稱，在撰寫時就不需要查表寫記憶體位址了。

### 4. Data Direct

將資料寫到 data space 當中。在 AVR 當中 data space 包含 Register file、I/O memory、SRAM。例如 `sts` 指令

```
sts 0x1000, r16
```

將 r16 的資料寫入到 data space 的位址 `0x1000` 。

AVR 採用的是哈佛架構（Harvard Architecture），在哈佛架構當中，**程式指令和資料儲存會分別存放在不同的記憶體空間**。目前使用哈佛架構的微控制器與中央處理器的晶片有 AVR、ARM9、ARM10、ARM11。

因此我們將資料儲存的地方稱為 data space，儲存指令的地方稱為 program memory space。將程式指令與資料儲存空間分開存放最大的好處在於，當我們在執行指令時，就可以預先讀取下一條指令，進而提高效能。

### 5. Data Indirect

間接定址。在 AVR 當中有三個比較特別的暫存器稱為 X, Y, Z 暫存器。我們在前面有講到，AVR 具有 32 個通用暫存器，分別從 r0 ~ r31，其中 r26 ~ r31 在特定指令中會具有定址功能，而當這些暫存器當作定址功能使用時就稱為 X、Y、Z 暫存器。

![截圖 2021-10-02 上午1.50.43.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a17408e-ef36-489a-882a-6af278fc7a5f/截圖_2021-10-02_上午1.50.43.png)

```
LD r16, Y
```

這個指令的意思是以 Y 的值當作**記憶體位址**，找出此記憶體位址儲存的值，再將值放入 r16 暫存器當中。因為不是**直接**將值放入暫存器中，而是先找記憶體位址再去找值，因此才有 indriect 之稱。從這個指令多少就能感受出指標在組合語言的表達是什麼，其實就是 indirect 的對應。

除此之外 AVR 還有提供執行後增、減的功能。

```
LD r16, Y+
```

當執行完這條指令後，將 Y 暫存器的值 +1，這樣在存取連續的記憶體空間時很方便。

```
ST Y+, r28
```

這條指令則是將暫存器 r28 的內容存入到以 Y 暫存器的值為位址的記憶體。

### 6. Data Indriect with displacement

可以在 X、Y、Z 當中自行加入常數的 offset

```
LDD r16, Y+0x10
```

將 Y 的值加上 0x10 後當作記憶體位址去尋找對應的值。

### 7. Program memory addressing

可以使用 Z 暫存器當作記憶體位址存取到 program memory。

```
LPM
```

### 8. Indriect program addressing

使用 `ijump` 或是 `icall` 時可根據 z-register 的值改寫 PC 的位址。

PC 指得是 program counter，在 MCU 當中會不斷從 flash memory 當中獲取下一條指令解碼後執行，為了得知目前執行到哪一條指令，通常會使用 program counter 來儲存，每次執行一條指令時就將 PC+1。PC 可透過 ijump、icall 修改，讓程式跳到指定的位置後執行，進而實現像是迴圈、條件式判斷、函數呼叫等功能。

### 9. Relative Program Addressing

以 ijump 與 icall 都是直接以記憶體位址改動 PC 值，也可以透過 offset 的方式來改變。

```
rjmp r16
rcall r16
```

## 總結

AVR 的指令集雖然不多，但算下來也有 100 多條，文章裡無法一一介紹，不過我會在接下來介紹到特定功能時，一併介紹對應的指令。


GPIO 全文為 General purpose input/output，在微控制器當中通常具有控制引腳輸出或輸入的功能，可以透過程式控制某一腳位的輸出為高電位或低電位。

一個最簡單的例子可以用 LED 燈來舉例，假設今天想要實作 LED 閃爍功能，我們可以將 LED 的一個接腳接地之後，另一接腳接到 GPIO 腳位，並透過程式控制輸出的電位高低，這樣就可以做到閃爍效果。

既然一個引腳可以用於輸入、輸出或其他特殊功能，那麼在程式實作上，要怎麼去控制腳位的輸出呢？在微控制器當中可以**透過修改暫存器的數值**來做到。

如下圖所示，微控制器內部的特殊暫存器會存在特定記憶體位址當中（在 datasheet 可以找到），只要修改對應記憶體位址中的資料，就可以修改暫存器的值。

不過在程式上不需要寫死記憶體位址，編譯器以及 assembler 都會事先定義好變數讓開發者使用。

![截圖 2021-10-09 下午12.00.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b7fecd9-77b3-4972-892a-e9623b144287/截圖_2021-10-09_下午12.00.08.png)

## GPIO Port

事先定義好的一組腳位稱做 PORT。在 attiny85 當中有一個 PORT（PORTB），總共 6 個腳位。

![截圖 2021-10-09 下午12.05.43.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e1697b59-dd6f-4aa0-9b2f-09b9cec998c1/截圖_2021-10-09_下午12.05.43.png)

如圖所示，當中的 PB0 ~ PB5 就是 PORTB 接腳的意思，括號後的名稱則是除了 GPIO 接腳之外，根據程式的設定也可以當作其他用途。

## 輸入、輸出

每個 GPIO 都具有輸出與輸入功能。

- 輸出：由控制器**輸出**高電位或低電位（0 或 1）
- 輸入：由**外部設備**輸入高電位或低電位至控制器

為了要控制腳位為輸入或輸出，以及個別腳位應該如何控制，需要知道兩個暫存器分別為 PORTB、DDRB。

### DDRB（Data Direction Register B）

控制接腳的功能為輸入還是輸出。0 為輸入 1 為輸出。輸入指得是由**外部設備**輸入高電位或低電位至控制器；而輸出指得是由控制器**輸出**高電位或低電位（0 或 1）。

### PORTB

有 8bit，但 attiny85 只有 6 個腳位，因此最上面的兩個 bit 不會使用到。PORTB 可用來控制腳位輸出高低。

一個簡單的 GPIO 程式如下：

```c
#include <avr/io.h>
#include <util/delay.h>

int main(void)
{
  DDRB = (1 << DDB0);     // set PORTB0 as output and port1 ~ 7 as ouput. DDR means data direction register
  PORTB = (1 << PORTB0);  // set PORTB0 to 1 (HIGH)
  unsigned char i = PINB; // read pin from PINB register
  return 0;
}
```

程式當中我們將 DDB0（第 1 個 bit）設定為 1 代表輸出，PORTB0 設定為 1（代表輸出高電位），其效果約略等同於 arduino 當中的：

```c
void setup() {
  pinMode(PIN, OUT);
}

void loop() {
  digitalWrite(PIN, HIGH);
}
```

接下來在加上 delay 以及無窮迴圈即可完成 LED 閃爍效果：

```c
#include <avr/io.h>
#include <util/delay.h>

int main(void)
{
  while (1) {
    DDRB = (1 << DDB0);     // set PORTB0 as output and port1 ~ 7 as ouput. DDR means data direction register
    PORTB = (1 << PORTB0);  // set PORTB0 to 1 (HIGH)
    unsigned char i = PINB; // read pin from PINB register

    _delay(500);
	  PORTB = ~(1 << PORTB0);
	  _delay(500);
  }
  return 0;
}
```

[IMG_1257.MOV](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c78f9db7-04a6-482c-ad58-eba713e95faa/IMG_1257.mov)
